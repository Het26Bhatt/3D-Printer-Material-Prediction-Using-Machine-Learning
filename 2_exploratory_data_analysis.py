# -*- coding: utf-8 -*-
"""Milestone 2: Exploratory Data Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lfefB_UZw2k2sfc_TcPItFeeO0b6aOVp
"""

# Importing necessary libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score
from sklearn.neighbors import KNeighborsClassifier
from xgboost import XGBClassifier
from sklearn.naive_bayes import GaussianNB

data = pd.read_csv('/content/adxl_data/ADXL345_SensorData.csv')

data.describe()

data['Error_found'].value_counts()

plt.figure(figsize=(10, 5))
sns.histplot(data['X-direction'],bins= 30, kde=True)
plt.title('distribution of x direction vibrations')
plt.show()

plt.figure(figsize=(10, 5))
sns.kdeplot(data['X-direction'], shade=True)
plt.title('KDE Plot of X-direction Vibrations')
plt.xlabel('X-direction')
plt.ylabel('Density')
plt.show()

plt.figure(figsize=(10, 5))
sns.kdeplot(data['Y-direction'], shade=True)
plt.title('KDE Plot of Y-direction Vibrations')
plt.xlabel('Y-direction')
plt.ylabel('Density')
plt.show()

plt.figure(figsize=(10, 5))
sns.kdeplot(data['Z-direction'], shade=True)
plt.title('KDE Plot of Z-direction Vibrations')
plt.xlabel('Z-direction')
plt.ylabel('Density')
plt.show()

plt.figure(figsize=(10, 5))
sns.scatterplot(x='X-direction',y='Y-direction', hue='Error_found', data=data)
plt.title('Scatter Plot of X-direction vs Y-direction')
plt.xlabel('X-direction')
plt.ylabel('Y-direction')
plt.show()

plt.figure(figsize=(10, 5))
sns.violinplot(x='Error_found',y='X-direction',  data=data)
plt.title('violin plot of X-direction vibration by Error_found')
plt.xlabel('Error_found')
plt.ylabel('X-direction vibrations')
plt.show()

data['Error_found']=data['Error_found'].map({'no': 0,'yes': 1})
plt.figure(figsize=(10, 8))
sns.heatmap(data.corr(), annot=True, cmap='coolwarm')
plt.title('Correlation Heatmap')
plt.show()

X = data[['X-direction', 'Y-direction', 'Z-direction']]
y = data['Error_found']

# prompt: This code performs feature scaling on the input data using Min-Max scaling, which transforms the data to a specific range (usually between 0 and 1). This scaling is crucial because it ensures that all input features contribute equally to the model training process, preventing any particular feature from dominating due to its larger magnitude.

from sklearn.preprocessing import MinMaxScaler

scaler = MinMaxScaler()
X_scaled = scaler.fit_transform(X)

# Display the first few rows of the scaled data
print("Scaled data (first 5 rows):\n", X_scaled[:5])

X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=42)

y_train.value_counts()

from imblearn.over_sampling import SMOTE
smote = SMOTE()
X_train, y_train = smote.fit_resample(X_train, y_train)
y_train.value_counts()